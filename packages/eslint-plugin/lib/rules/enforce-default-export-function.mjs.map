{"version":3,"file":"enforce-default-export-function.mjs","names":["TSESTree"],"sources":["../../src/rules/enforce-default-export-function.ts"],"sourcesContent":["import { TSESTree } from '@typescript-eslint/types';\nimport { ESLintUtils, TSESLint } from '@typescript-eslint/utils';\n\nconst createRule = ESLintUtils.RuleCreator(name => `https://github.com/Benjas333/SAMMI-Next/tree/master/packages/eslint-plugin/docs/rules/${name}.md`);\n\nexport const enforceDefaultExportFunction = createRule({\n    name: 'enforce-default-export-function',\n    meta: {\n        docs: {\n            description: 'enforce the default export is a function with no parameters',\n        },\n        type: 'problem',\n        messages: {\n            'problem:default-export-not-function': 'Default export must be a function.',\n            'problem:default-export-has-params': 'Default export function must not have parameters.'\n        },\n        schema: [],\n    },\n    defaultOptions: [],\n    create: context => {\n        const sourceCode = context.sourceCode;\n        const parserServices = sourceCode.parserServices;\n        const checker = parserServices && parserServices.program ? parserServices.program.getTypeChecker() : null;\n\n\n        function isFunctionNode(node: TSESTree.Node | null): boolean {\n            if (!node) return false;\n\n            const type = node.type;\n            return (\n                type === TSESTree.AST_NODE_TYPES.FunctionDeclaration ||\n                type === TSESTree.AST_NODE_TYPES.FunctionExpression ||\n                type === TSESTree.AST_NODE_TYPES.ArrowFunctionExpression\n            );\n        }\n\n        function nodeHasParams(node: TSESTree.Node | null): boolean {\n            if (!node) return false;\n\n            if (\n                node.type === TSESTree.AST_NODE_TYPES.FunctionDeclaration ||\n                node.type === TSESTree.AST_NODE_TYPES.FunctionExpression ||\n                node.type === TSESTree.AST_NODE_TYPES.ArrowFunctionExpression\n            ) {\n                const params = node.params;\n                return Array.isArray(params) && params.length > 0;\n            }\n\n            if (node.type === TSESTree.AST_NODE_TYPES.CallExpression) {\n                if (!parserServices || !checker || !parserServices.esTreeNodeToTSNodeMap) return true;\n\n                try {\n                    const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n                    const type = checker.getTypeAtLocation(tsNode);\n                    if (!type) return true;\n\n                    const sigs = type.getCallSignatures();\n                    if (sigs && sigs.length > 0) {\n                        for (const s of sigs) {\n                            const params = s.getParameters();\n                            if (params && params.length > 0) return true;\n                        }\n\n                        return false;\n                    }\n\n                    if (type.isUnion() && typeof type.types === 'object') {\n                        const parts = type.types;\n                        for (const p of parts) {\n                            const psigs = p.getCallSignatures();\n                            for (const s of psigs) {\n                                if (s.getParameters().length > 0) return true;\n                            }\n                        }\n\n                        return false;\n                    }\n\n                    return true;\n                } catch {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        function CallExpressionReturnsFunction(node: TSESTree.Node | null): boolean {\n            if (!node || node.type !== TSESTree.AST_NODE_TYPES.CallExpression) return false;\n            if (!parserServices || !checker || !parserServices.esTreeNodeToTSNodeMap) return false;\n\n            try {\n                const tsNode = parserServices.esTreeNodeToTSNodeMap.get(node);\n                const type = checker.getTypeAtLocation(tsNode);\n                if (!type) return false;\n\n                const sigs = type.getCallSignatures();\n                if (sigs && sigs.length > 0) return true;\n\n                if (type.isUnion() && Array.isArray(type.types)) {\n                    for (const part of type.types) {\n                        const psigs = part.getCallSignatures();\n                        if (psigs && psigs.length > 0) return true;\n                    }\n                }\n\n                return false;\n            } catch {\n                return false;\n            }\n        }\n\n        const reportOnParams = (node: TSESTree.Node) => {\n            if (!nodeHasParams(node)) return;\n\n            context.report({\n                node,\n                messageId: 'problem:default-export-has-params'\n            });\n        }\n\n        return {\n            ExportDefaultDeclaration: node => {\n                const decl = node.declaration;\n\n                if (isFunctionNode(decl)) {\n                    reportOnParams(decl);\n                    return;\n                }\n\n                if (decl && decl.type === TSESTree.AST_NODE_TYPES.CallExpression) {\n                    if (CallExpressionReturnsFunction(decl)) {\n                        reportOnParams(decl);\n                        return;\n                    }\n                }\n\n                if (decl && decl.type === TSESTree.AST_NODE_TYPES.Identifier) {\n                    let scope: TSESLint.Scope.Scope | null = sourceCode.getScope(node);\n\n                    let defNode: TSESTree.Node | null = null;\n                    while (scope) {\n                        const variable = scope.set.get(decl.name);\n                        if (variable && variable.defs && variable.defs.length) {\n                            defNode = variable.defs[0].node;\n                            break;\n                        }\n\n                        scope = scope.upper;\n                    }\n\n                    if (defNode) {\n                        if (isFunctionNode(defNode)) {\n                            reportOnParams(defNode);\n                            return;\n                        }\n\n                        if (defNode.type === TSESTree.AST_NODE_TYPES.VariableDeclarator && defNode.init) {\n                            const init = defNode.init;\n\n                            if (isFunctionNode(defNode.init)) {\n                                reportOnParams(defNode.init);\n                                return;\n                            }\n\n                            if (\n                                init.type === TSESTree.AST_NODE_TYPES.CallExpression &&\n                                CallExpressionReturnsFunction(init)\n                            ) {\n                                reportOnParams(init);\n                                return;\n                            }\n                        }\n                    }\n                }\n\n                context.report({\n                    node,\n                    messageId: 'problem:default-export-not-function'\n                })\n            }\n        };\n    },\n});\n"],"mappings":";;;;;AAGA,MAAM,aAAa,YAAY,aAAY,SAAQ,yFAAyF,KAAK,KAAK;AAEtJ,MAAa,+BAA+B,WAAW;CACnD,MAAM;CACN,MAAM;EACF,MAAM,EACF,aAAa,+DAChB;EACD,MAAM;EACN,UAAU;GACN,uCAAuC;GACvC,qCAAqC;GACxC;EACD,QAAQ,EAAE;EACb;CACD,gBAAgB,EAAE;CAClB,SAAQ,YAAW;EACf,MAAM,aAAa,QAAQ;EAC3B,MAAM,iBAAiB,WAAW;EAClC,MAAM,UAAU,kBAAkB,eAAe,UAAU,eAAe,QAAQ,gBAAgB,GAAG;EAGrG,SAAS,eAAe,MAAqC;AACzD,OAAI,CAAC,KAAM,QAAO;GAElB,MAAM,OAAO,KAAK;AAClB,UACI,SAASA,qBAAS,eAAe,uBACjC,SAASA,qBAAS,eAAe,sBACjC,SAASA,qBAAS,eAAe;;EAIzC,SAAS,cAAc,MAAqC;AACxD,OAAI,CAAC,KAAM,QAAO;AAElB,OACI,KAAK,SAASA,qBAAS,eAAe,uBACtC,KAAK,SAASA,qBAAS,eAAe,sBACtC,KAAK,SAASA,qBAAS,eAAe,yBACxC;IACE,MAAM,SAAS,KAAK;AACpB,WAAO,MAAM,QAAQ,OAAO,IAAI,OAAO,SAAS;;AAGpD,OAAI,KAAK,SAASA,qBAAS,eAAe,gBAAgB;AACtD,QAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,eAAe,sBAAuB,QAAO;AAEjF,QAAI;KACA,MAAM,SAAS,eAAe,sBAAsB,IAAI,KAAK;KAC7D,MAAM,OAAO,QAAQ,kBAAkB,OAAO;AAC9C,SAAI,CAAC,KAAM,QAAO;KAElB,MAAM,OAAO,KAAK,mBAAmB;AACrC,SAAI,QAAQ,KAAK,SAAS,GAAG;AACzB,WAAK,MAAM,KAAK,MAAM;OAClB,MAAM,SAAS,EAAE,eAAe;AAChC,WAAI,UAAU,OAAO,SAAS,EAAG,QAAO;;AAG5C,aAAO;;AAGX,SAAI,KAAK,SAAS,IAAI,OAAO,KAAK,UAAU,UAAU;MAClD,MAAM,QAAQ,KAAK;AACnB,WAAK,MAAM,KAAK,OAAO;OACnB,MAAM,QAAQ,EAAE,mBAAmB;AACnC,YAAK,MAAM,KAAK,MACZ,KAAI,EAAE,eAAe,CAAC,SAAS,EAAG,QAAO;;AAIjD,aAAO;;AAGX,YAAO;YACH;AACJ,YAAO;;;AAIf,UAAO;;EAGX,SAAS,8BAA8B,MAAqC;AACxE,OAAI,CAAC,QAAQ,KAAK,SAASA,qBAAS,eAAe,eAAgB,QAAO;AAC1E,OAAI,CAAC,kBAAkB,CAAC,WAAW,CAAC,eAAe,sBAAuB,QAAO;AAEjF,OAAI;IACA,MAAM,SAAS,eAAe,sBAAsB,IAAI,KAAK;IAC7D,MAAM,OAAO,QAAQ,kBAAkB,OAAO;AAC9C,QAAI,CAAC,KAAM,QAAO;IAElB,MAAM,OAAO,KAAK,mBAAmB;AACrC,QAAI,QAAQ,KAAK,SAAS,EAAG,QAAO;AAEpC,QAAI,KAAK,SAAS,IAAI,MAAM,QAAQ,KAAK,MAAM,CAC3C,MAAK,MAAM,QAAQ,KAAK,OAAO;KAC3B,MAAM,QAAQ,KAAK,mBAAmB;AACtC,SAAI,SAAS,MAAM,SAAS,EAAG,QAAO;;AAI9C,WAAO;WACH;AACJ,WAAO;;;EAIf,MAAM,kBAAkB,SAAwB;AAC5C,OAAI,CAAC,cAAc,KAAK,CAAE;AAE1B,WAAQ,OAAO;IACX;IACA,WAAW;IACd,CAAC;;AAGN,SAAO,EACH,2BAA0B,SAAQ;GAC9B,MAAM,OAAO,KAAK;AAElB,OAAI,eAAe,KAAK,EAAE;AACtB,mBAAe,KAAK;AACpB;;AAGJ,OAAI,QAAQ,KAAK,SAASA,qBAAS,eAAe,gBAC9C;QAAI,8BAA8B,KAAK,EAAE;AACrC,oBAAe,KAAK;AACpB;;;AAIR,OAAI,QAAQ,KAAK,SAASA,qBAAS,eAAe,YAAY;IAC1D,IAAI,QAAqC,WAAW,SAAS,KAAK;IAElE,IAAI,UAAgC;AACpC,WAAO,OAAO;KACV,MAAM,WAAW,MAAM,IAAI,IAAI,KAAK,KAAK;AACzC,SAAI,YAAY,SAAS,QAAQ,SAAS,KAAK,QAAQ;AACnD,gBAAU,SAAS,KAAK,GAAG;AAC3B;;AAGJ,aAAQ,MAAM;;AAGlB,QAAI,SAAS;AACT,SAAI,eAAe,QAAQ,EAAE;AACzB,qBAAe,QAAQ;AACvB;;AAGJ,SAAI,QAAQ,SAASA,qBAAS,eAAe,sBAAsB,QAAQ,MAAM;MAC7E,MAAM,OAAO,QAAQ;AAErB,UAAI,eAAe,QAAQ,KAAK,EAAE;AAC9B,sBAAe,QAAQ,KAAK;AAC5B;;AAGJ,UACI,KAAK,SAASA,qBAAS,eAAe,kBACtC,8BAA8B,KAAK,EACrC;AACE,sBAAe,KAAK;AACpB;;;;;AAMhB,WAAQ,OAAO;IACX;IACA,WAAW;IACd,CAAC;KAET;;CAER,CAAC"}